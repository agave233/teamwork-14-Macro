### lisp宏的来由

lisp的语言规范本身是简单的，它的代码均由描述S-表达式的括号和列表构成。语言规范本身就蕴含在[^lisp form]中。lisp被奉为可编程的编程语言，这句话道出了lisp最大的优势，你也永远不会遇到这样 的一种情况：语言里面刚好缺乏某种可能令程序更容易编写的特性，因为你可以自己添加你想要的特性。

[^lisp form]: 能够被求值的合法的S-表达式。

__lisp语言处理器__

与大多数编程语言处理器不同的是（一个黑箱包含多个子系统），lisp语言处理器分为两个黑箱——读取器和求值器。每个黑箱都定义了一个的语法层面。

-  读取器读取一段文本代码，转化为S-表达式。读取器定义了字符串如何被转化为S-表达式的规则。
-  求值器则对建立在S-表达式之上的lisp form进行求值。求值器定义了在S-表达式之上的lisp form的语法规则（指明了那些是合法的S-表达式）和求值规则。

__lisp引入宏__

lisp形式除函数调用外，包含固定数目的特殊操作符，每个操作符定义了自己的语法结构（有限的不够用的）。例如最基本的条件执行形式是由IF特殊操作符。其基本形式为

```common lisp
(if condition then-form [else-form])
;例如
（if (> 3 2) "yup" "nope"） --> "yup"
```

但是事实上IF并不是什么伟大的构造，因为then-form 和else-form都被限制为单一的lisp形式，举个例子，如果你想要实现一个if条件满足执行多条语句时，你并不能这样写：

```common lisp 
(if condition
	(action 1)
	(action 2))
```

它会将action2 当成else-form。正确的做法应当是按顺序放在一个特殊操作符PROGN下。

```commonlisp
(if condition
	(progn
		(action 1)
		(action 2)))
```

再不说但是，估计lisp马上被喷做垃圾了。确实这无疑是很不好的，它没能从抽象层面上来实现一个if的功能。这里我们马上也能注意到这种由IF加上PROGN所组成的模式，并且希望可以有一种方式来抽象所有细节而不是每次都将它们写出来。

__这就是宏所能提供的功能__

除了像一般语言实现标准库的方式一样去扩展语言外，lisp宏让程序员在核心语言和标准库上面创造抽象，更直接简单的表达想表达的事物。这无疑极大地丰富了lisp语言。

比如我想实现一个until宏，它让其后的lisp形式能够被这样地求值器理解：如果条件为假时，你便对形式体求值，并返回，如果为真的话，那别求值。它可以这样被简单地实现：

```common lisp
（defmacro unless (cnodition &rest body)
	`(if condition 
		(progn ,@body))）
```

我们当然可以实现自己的for循环结构啊（要知道，这些语法结构在c语言中可是规定好了的语法生成式），甚至是一些更奇葩的语法。

__宏的说明__

1. 宏是一个函数，它以S-表达式作为参数，然后执行结果返回一个lisp形式。说白了就是能写代码的代码，是能直接操作语法树来实现语法的代码。
2. lisp解释器对宏的求值过程分为两部分：
   -  利用宏名后的列表传参给宏函数，然后产生展开式。
   -  对展开式求值。
3. 宏展开期实质是lisp代码的执行，但要注意宏展开期和代码运行期的重要区别：宏展开期间和运行期间代码运行环境是不同的，在宏展开期间是无法访问那些仅存在于运行期的数据。
4. 函数让我们抽象一定的功能，宏让我们抽象一定的语法规则。

__有漏洞的抽象__

编写宏是一种创造抽象的方法，可能会产生有漏洞的抽象。

例如前面提到的do-primes：

```common lisp
;求0到（random 100）内的素数
(do-primes (p 0 (random 100))
  (format t "~d " p))
```

展开之后发现（random 100）直接作为原子插入到对应的位置，所以（random 100）会被执行很多次：

```common lisp
CL-USER> (macroexpand-1 '(do-primes (p 0 (random 100)) (format t "~d " p)))
(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))
    ((> P (RANDOM 100)))
  (FORMAT T "~d " P))
```

当然这个是可以被修复的，这里只是想表达编写宏的可能出现的问题。

__对于宏的争论__

历史上lisp的支持者和黑lisp的两大阵营一般会拿macro说法：

支持者：

-  lisp是最强的，因为有宏，blabla。
-  macro并不是一个针对lisp缺少某些特性的补丁，而是一种让程序员和编译器交互的设计，为了实现元编程的任务，黑macro根本就是极端主义。

反对者：

-  lisp宏是可怕的，有害的，这就像使用goto语句一样。lisp的宏会降低代码可读性，你根本不知道一段代码的完整含义，除非你知道里面包含的所有宏的真实含义。其实lisp应该给用户更加结构化的方式去实修改语法树的方式，比如把某些特性统一加入一级特性中去。
-  宏一般是最后才使用的手段，能用函数解决，尽量使用函数吧

参考资料：
[ Practical common lisp ]: http://www.gigamonkeys.com/book/
[Macros are powerful but still a bad idea]: https://news.ycombinator.com/item?id=8698594
